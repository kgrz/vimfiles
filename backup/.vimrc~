" Pathogen
"filetype off " Pathogen needs to run before plugin indent on
call pathogen#infect()
call pathogen#runtime_append_all_bundles()
filetype off
syntax on
filetype plugin indent on

"call pathogen#helptags() " generate helptags for everything in 'runtimepath'
"filetype plugin indent on
" All system-wide defaults are set in $VIMRUNTIME/debian.vim (usually just
" /usr/share/vim/vimcurrent/debian.vim) and sourced by the call to :runtime
" you can find below.  If you wish to change any of those settings, you should


"VIM TEAM 
  " do it in this file (/etc/vim/vimrc), since debian.vim will be overwritten
  " everytime an upgrade of the vim packages is performed.  It is recommended to
  " make changes after sourcing debian.vim since it alters the value of the
  " 'compatible' option.
  
  " This line should not be removed as it ensures that various options are
  " properly set to work with the Vim-related packages available in Debian.
    runtime! debian.vim
  " Source a global configuration file if available
  if filereadable("/etc/vim/vimrc.local")
    source /etc/vim/vimrc.local
  endif

  " Uncomment the next line to make Vim more Vi-compatible
  " NOTE: debian.vim sets 'nocompatible'.  Setting 'compatible' changes numerous
  " options, so any other options should be set AFTER setting 'compatible'.
  "set compatible
  
  " The following are commented out as they cause vim to behave a lot
  " differently from regular Vi. They are highly recommended though.
  "set showcmd		" Show (partial) command in status line.
  "set showmatch		" Show matching brackets.
  "set ignorecase		" Do case insensitive matching
  "set smartcase		" Do smart case matching
  "set incsearch		" Incremental search
  "set autowrite		" Automatically save before commands like :next and :make
  "set hidden             " Hide buffers when they are abandoned
  "set mouse=a		" Enable mouse usage (all modes)

" SYNTAX 
  " Vim5 and later versions support syntax highlighting. Uncommenting the next
  " line enables syntax highlighting by default.
  if has("syntax")
    syntax on
  endif
  " If using a dark background within the editing area and syntax highlighting
  " turn on this option as well
  "set background=dark

"MEMORY 
  set backup
  set backupdir=~/.vim/backup
  set history=100000         " remember more commands and search history
  set undolevels=1000      " use many muchos levels of undo
  set title                " change the terminal's title, may not work
  set autoread    "when reopening a file, go to the position as when you quit it +  This will disable read-only to writeable warnings

"MOUSE
  " Send more characters for redraws
  set ttyfast
  set ttymouse=xterm2
  set mouse=a " Enable mouse use in all modes

"MAP = SHORTCUTS 
  " %% to expand path in command mode 
  cnoremap %% <C-R>=expand('%:p:h')<CR>
  """""""""""""""
  "Save with Crtl + S, need to disable something in bashrc  
  "noremap  <C-S>    :update<CR>   
  "vnoremap  <C-S>         <C-C>:update<CR> 
  "inoremap <C-S>         <C-O>:update<CR>
  " Change tab with shift+direction
  noremap <S-l> gt
  noremap <S-h> gT

  imap jk <Esc>

  " Save with crtl S 
  "command -nargs=0 -bar MyUpdate if &modified 
  "                         \|    if empty(bufname('%'))
  "                         \|        browse confirm write
  "                         \|    else
  "                         \|        confirm write
  "                         \|    endif
  "                         \|endif
  "nnoremap <silent> <C-S> :<C-u>MyUpdate<CR>
  "inoremap <c-s> <c-o>:MyUpdate<CR>

  "Get Ctrl + ARROW KEYS,because if you don't do that, the <C-Up>  (ie crtl + up ) key is notreckognise 
  map [1;5A <C-Up>
  map [1;5B <C-Down>
  map [1;5D <C-Left>
  map [1;5C <C-Right>

  map [1;2D <S-Left>
  map [1;2C <S-Right>
  cmap [1;2D <S-Left>
  cmap [1;2C <S-Right>


  " autocompletion with space
  inoremap <Nul> <C-n>
  ""for python_autocompletion
  "filetype plugin on
  "let g:pydiction_location = '~/.vim/staff/python_completion/'

  " change x and y, but take care, this is changing the x of max sometinmes you dont want that   
  map xy :s/x/y/g<CR>
  map yx :s/y/x/g<CR>

"FOLDING, and folding maps 
  "au BufWinLeave * mkview
  "au BufWinEnter * silent loadview
  "set foldmethod=indent 
  set shiftwidth=2  " the number of column taken into account for aa fold, IMPORTANT

  set foldmethod=expr
  set foldexpr=FoldMethod(v:lnum)
  
  function! FoldMethod(lnum)
    let crLine=getline(a:lnum)
  
    " check if empty line 
    if empty(crLine) "Empty line or end comment 
      return -1 " so same indent level as line before 
    endif 
  
    " check if comment  in syntax
    let a:data=join( map(synstack(a:lnum, 1), 'synIDattr(v:val, "name")') )
    if a:data =~ ".*omment.*"
      return '='

  "Otherwise return foldlevel equal to ident /shiftwidth (like if
  "foldmethod=indent)
    else  "return indent base fold
      return indent(a:lnum)/&shiftwidth
    endif 
  endfunction
  "
  nnoremap <space> za
  vnoremap <space> zf
  set foldcolumn=0  "the number of columns on the left to show the tree, default =0 
  set foldlevel=10  " WTF 
  "set foldlevelstart=5 "the folding at opening
  highlight Folded ctermfg=DarkGreen ctermbg=Black

  nnoremap <silent> <C-Right> zr
  vnoremap <silent> <C-Right> zr

  nnoremap <silent> <C-Left> zm
  vnoremap <silent> <C-Left> zm

  nnoremap <silent> <C-Up> zR
  vnoremap <silent> <C-Up> zR

  nnoremap <silent> <C-Down> zM
  vnoremap <silent> <C-Down> zM

  " this is to fold with only one line  
    "setlocal foldmethod=expr
    "setlocal foldexpr=(getline(v:lnum)=~'^$')?-2:((indent(v:lnum)<indent(v:lnum+2))?('>'.indent(v:lnum+2)):indent(v:lnum))
    "set foldtext=getline(v:foldstart)
    "set fillchars=fold:\ "(there's a space after that \)

    "" Fold all what isn't search typing \z after searching
    "" nnoremap \z :setlocal foldexpr=(getline(v:lnum)=~@/)?0:(getline(v:lnum-1)=~@/)\\|\\|(getline(v:lnum+1)=~@/)?1:2 foldmethod=expr foldlevel=0 foldcolumn=2<CR> 
    ""Use zr to display more context, or zm to display less context. 
    "" command! -nargs=+ Foldsearch exe "normal /".<q-args>."^M" | setlocal foldexpr=(getline(v:lnum)=~@/)?0:(getline(v:lnum-1)=~@/)\|\|(getline(v:lnum+1)=~@/)?1:2 foldmethod=expr foldlevel=0 foldcolumn=2 " to det rid of the z entirely 

" COPY PASTE TO CLIPboard with ctrl + y ctrl +p , need to run vimx 
  nnoremap <C-y> "+y
  vnoremap <C-y> "+y
  nnoremap <C-p> "+p
  vnoremap <C-p> "+p
  "nnoremap <C-p> "+gP
  "vnoremap <C-p> "+gP

" BUFFER MANAGEMENT 
  map <Tab> :bnext<cr>
  map <S-Tab> :bprevious<cr>
  noremap <C-Tab> :BufExplorer<CR>
  "noremap <C-Up> :bp
  "noremap! <C-Up> :bp
  "noremap <C-Down> :bn
  "noremap! <C-Down> :bn
  " from http://vim.wikia.com/wiki/Easier_buffer_switching
  set wildchar=<Tab> wildmenu wildmode=full
  set wildcharm=<C-Z>
  nnoremap <F10> :b <C-Z>
  " Mappings to access buffers (don't use "\p" because a
  " " delay before pressing "p" would accidentally paste).
  " " \l       : list buffers
  " " \b \f \g : go back/forward/last-used
  " " \1 \2 \3 : go to buffer 1/2/3 etc
  map <Leader>l :ls<CR>
  map <Leader>b :bp<CR>
  map <Leader>f :bn<CR>
  map <Leader>g :e#<CR>
  map <Leader>1 :1b<CR>
  map <Leader>2 :2b<CR>
  map <Leader>3 :3b<CR>
  map <Leader>4 :4b<CR>
  map <Leader>5 :5b<CR>
  map <Leader>6 :6b<CR>
  map <Leader>7 :7b<CR>
  map <Leader>8 :8b<CR>
  map <Leader>9 :9b<CR>
  map <Leader>0 :10b<CR>
  " " It's useful to show the buffer number in the status line.
  " set laststatus=2 statusline=%02n:%<%f\ %h%m%r%=%-14.(%l,%c%V%)\ %P
  function! BufSel(pattern) " switch to the closeset buffer
    let bufcount = bufnr("$")
    let currbufnr = 1
    let nummatches = 0
    let firstmatchingbufnr = 0
    while currbufnr <= bufcount
      if(bufexists(currbufnr))
        let currbufname = bufname(currbufnr)
        if(match(currbufname, a:pattern) > -1)
          echo currbufnr . ": ". bufname(currbufnr)
          let nummatches += 1
          let firstmatchingbufnr = currbufnr
        endif
      endif
      let currbufnr = currbufnr + 1
    endwhile
    if(nummatches == 1)
      execute ":buffer ". firstmatchingbufnr
    elseif(nummatches > 1)
      let desiredbufnr = input("Enter buffer number: ")
      if(strlen(desiredbufnr) != 0)
        execute ":buffer ". desiredbufnr
      endif
    else
      echo "No matching buffers"
    endif
  endfunction

"Bind the BufSel() function to a user-command
command! -nargs=1 Bs :call BufSel("<args>")


  
" ARITMETIC 
  ino <C-A> <C-O>yiW<End>=<C-R>=<C-R>0<CR>
  "just type 8*9 c-a and get the result 



"SEARCH"
  set smartcase
      "/copyright      " Case insensitive
      "/Copyright      " Case sensitive
      "/copyright\C    " Case sensitive
      "/Copyright\c    " Case insensitive
  set hlsearch      " highlight search terms
  set incsearch     " show search matches as you type
 
"ABREVIATION
  "abclear to delete its 
  "for Abism
    ab abtut if G.tutorial:<CR>               text=""<CR>TutorialReturn({"title":"",<CR>"text":text,<CR>})<CR>return    
    ab WW if W.verbose >3 : print "


"EDITING, CURSOR , APPERANCE  
  " Uncomment the following to have Vim jump to the last position when
  " reopening a file
  "if has("autocmd")
  "  au BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g'\"" | endif
  "endif
  "set term=ansi  " to move in insert mode
  
  " Cursor useless 
  "  "mode n-v-c
  "highlight Cursor guifg=white guibg=black 
  "" insert mode 
  "highlight iCursor guifg=white guibg=steelblue
  "" set nvc
  "set guicursor=n-v-c:block-Cursor
  "" set insert
  "set guicursor+=i:ver100-iCursor
  "" blink nvc and i 
  "set guicursor+=n-v-c:blinkon0
  "set guicursor+=i:blinkwait10i
  
  " Enable CursorLine
  set cursorline
  " Default Colors for CursorLine
  highlight  CursorLine term=underline cterm=underline ctermbg=None ctermfg=None
  "Change Color when entering Insert Mode
  autocmd InsertEnter * highlight  CursorLine term=None cterm=None
  " Revert Color to default when leaving Insert Mode
  autocmd InsertLeave * highlight  CursorLine term=underline cterm=underline ctermbg=None ctermfg=None

  set number        "show line number
  set autoindent  " to have auto indentation when return line 



"COLOR 
colorscheme dante



"
"set directory=~/.vim/tmp

"set guicursor=n-v-c:block-Cursor
"set guicursor+=i:ver100-iCursor
"set guicursor+=n-v-c:blinkon0
"set guicursor+=i:blinkwait10


" ECLIM 
  set nocompatible
  filetype plugin indent on
  let g:EclimCompletionMethod = 'omnifunc'
 
"autocmd BufWinLeave .* mkview
"autocmd BufWinEnter .* silent loadview 
au BufWinLeave ?* mkview
au BufWinEnter ?* silent loadview


noremap <S-Down> :let tmp=getpos('.') <CR>:m+1 <CR>: call cursor(tmp[1]+1,tmp[2]) <CR>
noremap <S-Up>   :let tmp=getpos('.') <CR>:m-2 <CR>: call cursor(tmp[1]-1,tmp[2]) <CR>
" move oneline
vnoremap <S-Up> :m '<-2<CR>gv
vnoremap <S-Down>   :m '>+1<CR>gv

"nnoremap <A-j> :m .+1<CR>==
"nnoremap <A-k> :m .-2<CR>==
"inoremap <A-j> <Esc>:m .+1<CR>==gi
"inoremap <A-k> <Esc>:m .-2<CR>==gi
"vnoremap <A-j> :m '>+1<CR>gv=gv
"vnoremap <A-k> :m '<-2<CR>gv=gv

