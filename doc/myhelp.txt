*myhelp.txt*  Some of my (tinmarino) personal notes according to vim 
Maybe to put that instead of Mem/vim

===============================================================================
Contents ~

 0. Fast                                    		|myfast|
 1. Example 						|myexample|
  1. Regex |myregex|					|myregex|
 1. Commands                                    	|mycommand|
  1. The |myhelp| command
  1. The |:myunlet| command
  2. The |:myput| command
 2. Function                                      	|myfunction|
  1. Function to command				|myfunction2command| 
  1. Change the |mysearch| pattern
  1. The |mywrite| option
  2. The |myread| option
 3. Maps                                      		|mymaps|

 4. Web-sites                                    	|mywebsite|
  2. The |:myput| command
 5. Scripting                                    	|myscript|
  1. The IF command					|myif|
  2. The FOR, WHILE loop				|myfor|
  3. The Variables					|myvariables|
 6. Appearance    					|myappearance|
  1. The |mystatusline| At the bottom of the window    	|mystatusline| 
 7. Regiters						|myregister|
 8. Split 						|mysplit|



===============================================================================
                                                *myfast*
Fast ~

Shift+J removes the line change character from the current line, so by pressing "J" at any place in the line you can combine the current line and the next line in the way you want.  

the runtime! debian was making pathogen not working 

  gf                  |  open file name under cursor (SUPER)

  :r file            |     " Read text from 'file' and insert it below the current line

===============================================================================
                                                *myexample*
Example ~

-------------------------------------------------------------------------------
 *myregex* are following the NFA regular expression 

The pattern.txt explains a lot. 
\@! to negate 
>
  /^\(\(^.*cursor.*$\)\@!.*foo.*\)$
<
-------------------------------------------------------------------------------
 *myexists* if variable exists  
>
  echom exists('g:a')
<


===============================================================================
                                                *mycommand*
Commands ~

-------------------------------------------------------------------------------
The *myhelp* command 
>
  :help E872
<
http://vim.wikia.com/wiki/Learn_to_use_help
:helptags ~/.vim/doc
  When you get |myerror| 
  Press Ctrl-] to follow the link (jump to the quickref topic). 
After browsing the quickref topic, press Ctrl-T to go back to the previous
topic.
You can also press Ctrl-O to jump to older locations, or Ctrl-I to jump to
newer locations. 
-------------------------------------------------------------------------------
The *:myunlet* command

To delete a variable. 
>
   :unlet g:max
<



-------------------------------------------------------------------------------
The *:myput* command

To put the result string of an expression. at the cursor position in current
buffer.  
>
   :put =range(11,15)
<


===============================================================================
                                                 *myfunction*
Function ~

To see a list of all functions and respectively to see them by use :
>
  :help functions 
  :help function-list
<
Function are defined like 
>
  function! (arg1,arg2) 
  endfunction
<
  Where we dont know the |type()| of the argument, the ! silently forces reload if
  function if defined yet. The undo and search pattern are restored after
  function call. 

-------------------------------------------------------------------------------
*myfunction2command* 
>
command! -nargs=1 MyCommand call s:MyFunc(<f-args>) " transform a function to user-command

-------------------------------------------------------------------------------
Change the *mysearch* pattern 
>
  fun! X()
      /Hello
      let @/ = 'Hello'
  endfun
<
>
  redir @a 
  call bla()
  redir END 
<
-------------------------------------------------------------------------------
The *mywrite* option

You have many way to write a file, this must be written.
|g:mywrite| permits to do it.
I just wanted to write |vimrc| script.

-------------------------------------------------------------------------------
The *myexec* option

  function Func()
    : command1
    : command2
  endfunction
  exec Func() 
===============================================================================
                                                 *mymaps*
Maps ~

Well you know maps are used to map thing around 
  :nmap - Display normal mode maps
  :imap - Display insert mode maps
  :vmap - Display visual and select mode maps
  :smap - Display select mode maps
  :xmap - Display visual mode maps
  :cmap - Display command-line mode maps
  :omap - Display operator pending mode maps


  nmapclear - Clear all normal mode maps
  "insert the directory name of the current buffer:
  :inoremap <F2> <C-R>=expand('%:p:h')<CR>
  From a normal mode map, you can get the keyword under the cursor using the expand('<cword>') function or using the <C-R><C-W> command
  The '< Vim mark represents the beginning line of a visual region and the '> mark represents the ending line of the visual region



===============================================================================
                                                 *myscript*
Script ~

-------------------------------------------------------------------------------
                                                 *myif*

>
   if <expression>
   	...
   elseif <expression>
   	...
   else
   	...
   endif
<
Expression can be : 
   <string> == <string> : String equals.
   <string> != <string> : String does not equal.
   <string> =~ <pattern>: String matches pattern.
   <string> !~ <pattern>: String doesn’t match pattern.
   <operator>#          : Additionally match case.
   <operator>?          : Additionally don’t match case.
   exists('var')	; Check if varaible exists 

-------------------------------------------------------------------------------
                                                 *myfor*
>
  for <var> in <list>
  	continue
  	break
  endfor
  
  for [var1, var2] in [[1, 2], [3, 4]]
  	" on 1st loop, var1 = 1 and var2 = 2
  	" on 2nd loop, var1 = 3 and var2 = 4
  endfor


  while <expression>
  endwhile

  
  try
  	...
  catch <pattern (optional)>
  	" HIGHLY recommended to catch specific error.
  finally
  	...
  endtry
<


-------------------------------------------------------------------------------
                                                 *myvariables*

g:var - global.
a:var - function argument.
l:var - local to function.
b:var - local to buffer.
w:var - local to window.
t:var - local to tab.
v:var - Predefined by Vim.

	  datatypes : 
<Number>: 32-bit signed number.
>
    -123
    0x10
    0177
<
<Float>: Floating point number. Requires +float on vim compile
>
    123.456
    1.15e-6
    -1.1e3
<
<String>: NUL terminated string of 8-bit unsigned characters.
>
    "ab\txx\"--"
    'x-z''a,c'
<
<Funcref>: A reference to a function. Variables used for funcref objects must start with a capital letter.
>
    :let Myfunc = function("strlen")
    :echo Myfunc('foobar') " Call strlen on 'foobar'.
<
<List>: An ordered sequence of items.
>
    :let mylist = [1, 2, ['a', 'b']]
    :echo mylist[0]
    1
    :echo mylist[2][0]
    a
    :echo mylist[-2]
    2
    :echo mylist[999]
    E684: list index out of range: 999
    :echo get(mylist, 999, "THERE IS NO 1000th ELEMENT")
    THERE IS NO 1000th ELEMENT
<
<Dictionary>: An associative, unordered array. Each entry has a key and a value.
>
    :let mydict = {'blue': "#0000ff", 'foo': {999: "baz"}}
    :echo mydict["blue"]
    #0000ff
    :echo mydict.foo
    {999: "baz"}
    :echo mydict.foo.999
    baz
    :let mydict.blue = "BLUE"
    :echo mydict.blue
    BLUE
<

-------------------------------------------------------------------------------
                                                 *mystring*



  :5,8del | let l=split(@","\n") | 1,4s/$/\=remove(l,0)/
  1/ del
  2/ split buffer
  3/ remove(l,0) delete first elt of list l and return it :)
  
   will transfor : 
  work it 
  make it 
  do it 
  makes us 
  harder
  better
  faster
  stronger
  ~
  in 
  work it harder
  make it better
  do it faster
  makes us stronger
  

-------------------------------------------------------------------------------
                                                 *myarithmetic*

  :let result=(100*21)/23
  :echo printf("%d.%02d",result/100,result%100)
  %s/[0-9.]\+/\=2.0*str2float(submatch(0))/g 
  [0-9.]\+    one or more digits or periods
  \=  ...  evaluate following expression
  2.0 ... obvious
  *    ... also obvious
  str2float(submatch(0))  take entire match and convert that string to a float
  /g ...  as many matches as possible per line 
  %s/[0-9.]\+/\=2.0*str2float(submatch(0))/g 

  %s/\%8c\d*/\=submatch(0)*100  # for column 8, means string number 8 
  %s/\d\+/\=submatch(0)+2/g     # find all integer and add 2 to its
  :s/|\(\d\+\)/\='|'.(submatch(1)*60)/g
  :s/|\(\d\+\):\(\d\+\)/\='|'.(submatch(1)+submatch(2))/g
    transform 
    |23:58|6:40|
    |12:45|0:25|
    |36:13|12:00|
    in 
    |81|46|
    |57|25|
    |49|12|



HEX TO INT 
  IN command 
  :echo 0x123455 " will echo the dec value 
  :echo printf('%x',74565)

  IN insert 
 <C-R>=0x09ab<Enter> will insert 2475, and <C-R>=printf('0x%04x',2475)<Enter> will insert 0x09ab
  ctrl-R + ctrl-W paste in command move, the wrold under cursor 
  0x09378= 
  :let @b = substitute(@a,'\_s*\(.\{-}\)\_s*$','\1','') " this give the output in reg b 


===============================================================================
                                                 *myappearance*
Appearance ~

-------------------------------------------------------------------------------
The *mystatusline* option

This is a line at the bottom to get hud text. The ruler is supperposed to the
statusline. 
If you want to play with it, first run 
>
  set noruler
  set laststatus=2 
<
Then you can see what you are doing.

For a *default-statusline* you can take this one 
>
  :set statusline=%<%f\ %h%m%r\ %y%=%{v:register}\ %-14.(%l,%c%V%)\ %P
<
You can also change ruler with 
>
  :set rulerformat=%-14.(%l,%c%V%)\ %P
<


===============================================================================
                                                 *myregister*
Registers ~

-------------------------------------------------------------------------------

      :registers  "to view content 

  :normal @a  # to run macro a from ex command
  :g/vim/ normal @a  # run a for lines containing vim 
      To paste the content of a register in command <C-r> + name of the

        Corollary: Keep your search pattern but add an alternative: / Ctrl-R, / \|alternative.

        You could also have done: :call setreg('"', @", 'V') then p. The setreg function sets the register of which the name is given as first argument, initializes it with the contents of the second argument, and turns it into the mode specified in the third argument, V for linewise.
    
        cf. :help setreg(). The reverse functions are getreg() and getregtype().
        If you have recorded a macro with qa...q, then :echo @a will tell you
	what you have typed, and @a will replay the macro (probably you knew
	that one, very useful in order to avoid repetitive tasks)
	        cf. :help q, help @
		help @:  " does not contian carriage return so can be called
		in normal mode 

      In Insert or Command-line mode, Ctrl-R plus a register name, inserts the contents of this register. If you want to insert them literally (no auto-indenting, no conversion of control characters like 0x08 to backspace, etc), you can use Ctrl-R, Ctrl-O, register name. See :help i_CTRL-R and following paragraphs for more reference.
      register 
      ctrl-R + ctrl-W paste in command move, the wrold under cursor 



        Corollary from the previous example: If you have 8go in the clipboard, then @+ will play the clipboard contents as a macro, and thus go to the 8th byte of your file. Actually this will work with almost every register. If your last inserted string was dd in Insert mode, then @. will (because the . register contains the last inserted string) delete a line. (Vim documentation is wrong in this regard, since it states that the registers #, %, : and . will only work with p, P, :put and Ctrl-R).
    
        Show what you will be doing in Normal mode before running it: @='dd' Enter. As soon as you hit the = key, Vim switches to expression evaluation: as you enter an expression and hit Enter, Vim computes it, and the result acts as a register content. Of course the register = is read-only, and one-shot. Each time you start using it, you will have to enter a new expression.
        cf. :help quote_=
        Corollary: If you are editing a command, and you realize that you should need to insert into your command line some line from your current buffer: don't press Esc! Use Ctrl-R =getline(58) Enter. After that you will be back to command line editing, but it has inserted the contents of the 58th line.
    
    
        Copy all lines beginning with foo, and afterwards all lines containing bar to clipboard, chain these commands: qaq (resets the a register storing an empty macro inside it), :g/^foo/y A, :g/bar/y A, :let @+ = @a.
    
        Using a capital register name makes the register work in append mode
    
        Better, if Q has not been remapped by mswin.vim, start Ex mode with Q, chain those “colon commands” which are actually better called “Ex commands”, and go back to Normal mode by typing visual.
    
        cf. :help :g, :help :y, :help Q
    
        Double-space your file: :g/^/put _. This puts the contents of the black hole register (empty when reading, but writable, behaving like /dev/null) linewise, after each line (because every line has a beginning!).
    
        Add a line containing foo before each line: :g/^/-put ='foo'. This is a clever use of the expression register. Here, - is a synonym for .-1 (cf. :help :range). Since :put puts the text after the line, you have to explicitly tell it to act on the previous one.
    
        Copy the entire buffer to the system clipboard: :%y+.
    
        cf. :help :range (for the % part) and :help :y.
    
        If you have misrecorded a macro, you can type :let @a=' Ctrl-R =replace(@a,"'","''",'g') Enter ' and edit it. This will modify the contents of the macro stored in register a, and it's shown here how you can use the expression register to do that.
    
        If you did dddd, you might do uu in order to undo. With p you could get the last deleted line. But actually you can also recover up to 9 deletes with the registers @1 through @9.
    
        Even better, if you do "1P, then . in Normal mode will play "2P, and so on.
    
        cf. :help . and :help quote_number
    
        If you want to insert the current date in Insert mode: Ctrl-R=strftime('%y%m%d')Enter.
    
        cf. :help strftime()

      In script, to read, write use @ : 
>
          :let @" = expand("%:p") "put in the unamed register the full path
	  of the file 
<

      a — Named register, "aY Replace the contents of register a with the current line 
      A — Append, "AY Append the current line to register a.
      "   Unamed register is the uname reg, everything going to a reg also go to this one
      _ is the black hole register, everything going to it go to /dev/nulla to avoid erase the standar register wehn deleting something 
      - the small delete (lesss than one line for example thing you delete with 3x
      . last inserted text 
      % filename 
      : command 
      / search 
      = expression # to take the result of an arbitrary expression 
      + and * are for interface with system clipboard "maybe install vimx 
      # Register % contains the name of the current file, and register # contains the name of the alternate file. These registers allow the name of the current or alternate files to be displayed or inserted. The name, or full path, or directory containing the file can be used. 


===============================================================================
                                                 *mysplit*
Split ~

:sp			| Split Screen horizontaly 
:vsp			| Split Screen vertically 
:sview 			| Same as :split in readonly mode
:hide 			| Close current window
:only 			| Close all windows, excepted current
Ctrl + w and Ctrl+w 	| sWitch viewport 
Ctrl + w and [hjkl]	| Move to the next viewport
ctrl + w and arrow	| Same
Ctrl + w and [+-] 	| Increase/decrease Current Viewport.
10 Ctrl + w and + 	| Add 10 lines to current window
Ctrl + w and =		| Igualise viewport size
"Ctrl + w and _		| Maximise current window
Ctrl + w and [rR]	| Change viewport position 
Ctrl + w and  q 	| Close current viewport


===============================================================================
                                                *mybuffer*
Buffer ~


:ls			| display buffer list

:bn			| new
:bd			| delete
:b3			| goto 3
:n :p			| next, previous
:rew 			| rewind to 1st file

:args 			| display argument list
:arg 			|Optional: Display the current arglist.
:arg *.cpp 		|All *.cpp files in current directory.
:argadd *.h 		|And all *.h files.
:argdo %s/pattern/replace/ge | update 	Search and replace in all files in arglist. 

:update			| save if changes
:bufdo 			| do the command to all buffer
:e!   			| return to unmodified file
:e #   			| edit alternative file
:e +name		| edit
:w /some/path/%:r 	| save file in another directory, but with the same name
:sav php.html     	| Save current file as php.html and "move" to php.html

:qa          		| quit all 

===============================================================================
                                                *mytab*
Tab ~

  	:tabnew 		Creates a new tab
  	:gt 			Show next tab
  	:tabfirst 		Show first tab
  	:tablast 		Show last tab
  	:tabm n(position) 	Rearrange tabs
  	:tabdo %s/foo/bar/g 	Execute a command in all tabs
  	:tab ball 		Puts all open files in tabs

===============================================================================
                                                *mysearch*
Search ~

:noh		no hightlight search 
/word 	        word from top to bottom
?word 	        word from bottom to top
/jo[ha]n 	john or joan
/fred\|joe 	fred or joe
/\<the 		the, theatre or then
/the\> 	        the or breathe
/\<the\> 	the
/\<\d\d\d\d\> 	exactly 4 digits
/^\n\{3} 	empty lines
/\cstring       Case insensitive 
:bufdo /searchstr/ 	Search in all open files


<ESC>:%s/.*/\L&/  # tranform everything to lowar case
<ESC>:%s/.*/\U&/  # upper
/\<[A-Z]\+\/ or /\v<[A-Z]+> or /\<\u\+\> # find upper case words


===============================================================================
                                                *mysubstitute*
Substite~

  	:%s/\<./\u&/g 	Sets first letter of each word to uppercase
  	:%s/\<./\l&/g 	Sets first letter of each word to lowercase
  	:%s/.*/\u& 	Sets first letter of each line to uppercase
  	:%s/.*/\l& 	Sets first letter of each line to lowercase



  see http://vimregex.com/
  :%s/fff/rrr    | replace first instance
  :%s/ff/rr/g    | replace all instances
  :%s/ff/rr/gc   | ask for confirmation
  :5,20s/ff/rr   | betwenn line  5 and 20
  :%!/^#/d       | delete lines not begining with #
  :%s/^/#        | append # at begining of line
  :g/^#/d  begining with #
  :g!/^#/d not begining with #
  :g/^$/d blanck lines 
  vim -u NONE -i NONE -Nnes "+se ul=-1" "+argdo %s/bite/W\.psf_fit\[0\]\[0\]/ge|up" "+q" *
  ^\(-*[0-9]*\.[0-9]*\s\)\{21}   " match the 21 first numbers like 12232.23 23.23 
  %s/^/\=line(".") . ". "/g    " substitute all lines by its line number 
  :4,$s/\d\+/\=submatch(0) + 1/ # add one to every one 

  s:\a*\a:\='"'.submatch(0).'"'
  However a more readable solution is:
  s:\a*\a:"\0"
  submatch(0) 
  strpart 
  s/[^"],/\=strpart(submatch(0),0,1)/g


  <ESC>:%s/.*/\L&/  # tranform everything to lowar case
  <ESC>:%s/.*/\U&/  # upper
  /\<[A-Z]\+\/ or /\v<[A-Z]+> or /\<\u\+\> # find upper case words


  	:%s/old/new/g 	Replace all occurences of old by new in file
  	:%s/old/new/gw 	Replace all occurences with confirmation
  	:2,35s/old/new/g 	Replace all occurences between lines 2 and 35
  	:5,$s/old/new/g 	Replace all occurences from line 5 to EOF
  	:%s/^/hello/g 	Replace the begining of each line by hello
  	:%s/$/Harry/g 	Replace the end of each line by Harry
  	:%s/onward/forward/gi 	Replace onward by forward, case unsensitive
  	:%s/ *$//g 	Delete all white spaces
  	:g/string/d 	Delete all lines containing string
  	:v/string/d 	Delete all lines containing which didn’t contain string
  	:s/Bill/Steve/ 	Replace the first occurence of Bill by Steve in current line
  	:s/Bill/Steve/g 	Replace Bill by Steve in current line
  	:%s/Bill/Steve/g 	Replace Bill by Steve in all the file
  	:%s/\r//g 	Delete DOS carriage returns (^M)
  	:%s/\r/\r/g 	Transform DOS carriage returns in returns
  	:%s#<[^>]\+>##g 	Delete HTML tags but keeps text
  	:%s/^\(.*\)\n\1$/\1/ 	Delete lines which appears twice
  Ctrl+a 	Increment number under the cursor
  Ctrl+x 	Decrement number under cursor
  	ggVGg? 	Change text to Rot13
  Case
  	g~~ 	Invert case
  	ggguG 	Set all text to lowercase
  	:set ignorecase 	Ignore case in searches
  	:set smartcase 	Ignore case in searches excepted if an uppercase letter is used

===============================================================================
                                                *myfold*
Fold ~


   :syn match comment "\v(^\s*//.*\n)+" fold
   set "foldtext", witch show what you see when folded 
   :set foldmethod=expr
   :set foldexpr=empty(getline(v:lnum))?'=':indent(v:lnum)/4
   zf#j creates a fold from the cursor down # lines.
   zf/ string creates a fold from the cursor to string .
   zj moves the cursor to the next fold.
   zk moves the cursor to the previous fold.
   zo opens a fold at the cursor.
  ->zO opens all folds at the cursor.
   zm increases the foldlevel by one.
  ->zM closes all open folds.
   zr decreases the foldlevel by one.
  ->zR decreases the foldlevel to zero -- all folds will be open.
   zd deletes the fold at the cursor.
   zE deletes all folds.
  ->[z move to start of open fold.
   ]z move to end of open fold.




EDIT 

  Read/Write files
  	:1,10 w outfile 	Saves lines 1 to 10 in outfile
  	:1,10 w >> outfile 	Appends lines 1 to 10 to outfile
  	:r infile 	Insert the content of infile
  	:23r infile 	Insert the content of infile under line 23
  File explorer
  	:e . 	Open integrated file explorer
  	:Sex 	Split window and open integrated file explorer
  	:browse e 	Graphical file explorer
  	:ls 	List buffers
  	:cd .. 	Move to parent directory
  	:args 	List files
  	:args *.php 	Open file list
  	:grep expression *.php 	Returns a list of .php files contening expression
  	gf 	Open file name under cursor
  Auto-completion
  	Ctrl+n Ctrl+p (in insert mode) 	Complete word
  	Ctrl+x Ctrl+l 	Complete line
  	:set dictionary=dict 	Define dict as a dictionnary
  	Ctrl+x Ctrl+k 	Complete with dictionnary
  
  



  bufdo normal 2G"Ayy

  which iterates through the buffers and runs the given command in normal mode. 2G jumps to the appropriate line, and "Ay yanks into register a, appending instead of overwriting (since the A is capitalized). Make sure register a is empty before you start
  
  :r filename 	insert filename after cursor
  :10r filename 	insert filename after line 10
  :g/pattern/r filename 	search pattern and insert filename after cursor
  :r !shell-command 	insert the result of a shell-command after cursor
  !!shell-command 	insert command output in place of current line
  :r foo.txt    Insert the file foo.txt below the cursor.
  :0r foo.txt   Insert the file foo.txt before the first line.
  :r !ls        Insert a directory listing below the cursor.
  :$r !pwd      Insert the current working directory below the last line.




vim: ft=help
