" The base
set encoding=utf-8
scriptencoding uft-8
filetype plugin indent on | syntax on
set pythonthreedll=/usr/lib/python3.7/config-3.7m-x86_64-linux-gnu/libpython3.7.so


" Variable
  let $PAGER = ''

  " Set v: windows gvim do NOT read .bashrc
  if has('win32') || has('win64')
    let $v = expand('$VIM/vimfiles')
    let $os = 'windows'
  endif
  set runtimepath+=$v

  " Alias
  " One letter
  let $h = expand($HOME)
  let $s = expand('$v/scripts') | let $script = $s
  let $w = expand('$h/wiki/wiki') | let $wiki = $w
  let $p = expand('$v/pack/bundle/opt') | let $pack = $p | let $opt = $p
  let $d = expand('$v/undo/dump') | let $dump = $d
  " RC
  let $alias = expand('$v/dotfile/bash_aliases.sh')
  let $bashrc = expand('$v/dotfile/bashrc')
  let $gitrc = expand('$v/dotfile/gitconfig')
  let $vimrc = expand('$v/dotfile/vimrc')
  let $tmuxrc = expand('$v/dotfile/tmux.conf')
  let $done = expand('$h/wiki/todo/done.md')
  " Vim
  let $auto = expand('$v/autoload')
  let $ft = expand('$v/ftplugin')
  let $vim = $v


" Os specific
  " Termux
  if 'termux' ==? $os
    " Autosave
    if expand('%') != ''
      augroup Autosave
        autocmd CursorHold,CursorHoldI *  silent update
      augroup END
    endif
    " Hide file edition message
    set shortmess+=F
  endif


" Appearance
  " Preferences
    set background=dark
    colorscheme gruvbox-material
    set t_Co=256  " For airline and nice colors
    set formatoptions-=cro  " No auto comment
    augroup NoCommment
      autocmd FileType * setlocal formatoptions-=c formatoptions-=r formatoptions-=o
    augroup END
    set diffopt+=vertical
    set title                    " change the terminal's title, may not work
    set autoindent  " to have auto indentation when return line
    set wrapscan
    set conceallevel=3
    set number
    set iskeyword+=#,-
    set iskeyword+=:
  " Statusline
    set laststatus=2        " alwaus show statusline
    set statusline=         " init void
    set statusline+=%m      " gflag modified
    set statusline+=%t      " tail of the filename
    set statusline+=%=      " left/right separator
    set statusline+=%P\ \   " percent through file
    set statusline+=%c,     " cursor column
    set statusline+=%l/%L   " cursor line/total lines
  " File format
    set fileformat=unix
    set wrap
    set expandtab
    set shiftwidth=4
    set tabstop=4
  " Gui
    set guifont=Consolas:h14:cANSI:qDRAFT
    set guioptions-=T                  " Toolbar
    set guioptions-=m                  " Menumbar
  " Wildignore : Ignore these filenames during enhanced command line completion.
    set wildmenu
    set wildmode=list:full
    set wildignore+=*.aux,*.out,*.toc,*.fdb_latexmk,*.pdf,*.fls,*.synctex.gz  " LaTeX intermediate files
    set wildignore+=*.tex.backup,*.lg,*.4ct,*.4tc,*.tmp,*.idv  " LaTeX html intermediate files
    set wildignore+=*.jpg,*.bmp,*.gif,*.png  " binary images
    set wildignore+=*.luac  " Lua byte code
    set wildignore+=*.o,*.obj,*.exe,*.dll,*.manifest  " compiled object files
    set wildignore+=*.pyc  " Python byte code
    set wildignore+=*.spl  " compiled spelling word lists
    set wildignore+=*.sw?  " Vim swap files
    set wildignore+=.git/*,undo/*  " Git, Vim undo
  " Search
    set ignorecase
    set smartcase
    set hlsearch      " highlight search terms
    set incsearch     " show search matches as you type
  " Cursor
    set cursorline  " Enable CursorLine
    " Default Colors for CursorLine
    highlight  CursorLine term=underline cterm=underline ctermbg=None ctermfg=None
    augroup Cursor
      "Change Color when entering Insert Mode
      autocmd InsertEnter * highlight  CursorLine term=None cterm=None
      " Revert Color to default when leaving Insert Mode
      autocmd InsertLeave * highlight  CursorLine term=underline cterm=underline ctermbg=None ctermfg=None
    augroup END

  " Window
    set ruler
    set backspace=2
    " set shell=H:/Program/cmder-1.2.9/Cmder.exe
  " Viminfo rememebr last 10000 opened files
  let s:viminfo=join(map(split(&viminfo, ','), {arg -> (v:val[0] == "'" ? "'10000" : v:val)}), ',')
  exe('set viminfo=' . s:viminfo)


" Backup
  set nobackup
  set noswapfile
  set nowritebackup
  set undolevels=10000
  set history=10000

  if has('persistent_undo')
    set undodir=$v/undo
    set undofile
  endif


" Mouse Integration
  " Send more characters for redraws
  set mouse=a " Enable mouse use in all modes
  set ttyfast
  set ttymouse=xterm2


" Map Leadered
  let mapleader = ','
  let maplocalleader = ','
  " Edit special files
    function! Edit(file)
      try | execute 'buffer ' . a:file
      catch | execute 'edit ' . a:file
      endtry
    endfunction
    nnoremap <Leader>ea :call Edit($alias)<CR>
    nnoremap <Leader>eb :call Edit($bashrc)<CR>
    nnoremap <Leader>ed :call Edit($h/wiki/todo/done.md)<CR>
    nnoremap <Leader>ef :e $v/ftplugin/<C-D>
    nnoremap <Leader>eg :call Edit($gitrc)<CR>
    nnoremap <Leader>et :call Edit($tmuxrc)<CR>
    nnoremap <Leader>ev :call Edit($vimrc)<CR>
  " b -> Backup file
    function! Backup(s)
      " Backup path
      let bck_file = expand('$v/undo/bck_') . strftime('%y-%m-%d-%H-%M-%S')
      " File path
      let bck_file .= '--' . substitute(expand('%:p:r'), '/', '_', 'g')
      " Extension
      let bck_file .= '-' . a:s . '.' . expand('%:e')
      silent execute a:s . 'write! ' . bck_file
      echom 'Backup lines ' . a:s . ' of file: $bck_file = ' . bck_file
    endfunction
    command! -range=% Backup call Backup('<line1>,<line2>')
    " :BackView to feed backup path of the day in command line
    command! -range=% BackupView call feedkeys(':e '
                \ . expand('$v/undo/bck_') . strftime('%y-%m-%d'))
    nnoremap <leader>b :Backup<CR>
    vnoremap <leader>b :Backup<CR>
  " n -> :NERDTree
    noremap <leader>n :packadd nerdtree<CR>:NERDTreeToggle<CR>
  " u -> :UndotreeToggle
    noremap <leader>u :silent packadd undotree<CR>:UndotreeToggle<CR>


" Map
  tnoremap <Esc> <C-W>N

  " Use <C-L> to clear the highlighting of :set hlsearch and also preserve the
  " default behavior of redrawing the screen
    if maparg('<C-S-L>', 'n') ==# ''
        nnoremap <silent> <C-S-L> :nohlsearch<C-R>=has('diff')?'<Bar>diffupdate':''<CR><CR><C-L>
    endif

  " Window
    noremap <C-W>- <C-W>s
    noremap <C-W>_ <C-W>s
    noremap <C-W><bar> <C-W>v
    " Up
    noremap  <C-Up>    <C-W>k
    noremap  <C-k>     <C-W>k
    inoremap <C-Up>    <C-O><C-W>k
    inoremap <C-k>     <C-O><C-W>k
    " Down
    noremap  <C-Down>  <C-W>j
    noremap  <C-j>     <C-W>j
    inoremap <C-Down>  <C-O><C-W>j
    inoremap <C-j>     <C-O><C-W>j
    " Left
    noremap  <C-Left>  <C-W>h
    noremap  <C-h>     <C-W>h
    inoremap <C-Left>  <C-O><C-W>h
    inoremap <C-h>     <C-O><C-W>h
    " Right
    noremap  <C-Right> <C-W>l
    noremap  <C-l>     <C-W>l
    inoremap <C-Right> <C-O><C-W>l
    inoremap <C-l>     <C-O><C-W>l

  " Maps for Package : On demand load
    " F8 : Colorscheme-switcher
    noremap <F8> :packadd misc<CR>:packadd colorscheme-switcher<CR><F8>
    map <ESC>[19;2~ <S-F8>

  " Yank all buffer to system clipboard
    map <leader>y mtgg"+yG`t
    map <leader>p ggdG"+p

  " Indent < and >
    noremap > >>
    noremap < <<
    vnoremap > >gv
    vnoremap < <gv

  " select last paste in visual mode
    nnoremap <expr> gb '`[' . strpart(getregtype(), 0, 1) . '`]'

  " Perso maps normal
    nnoremap H :set cursorline! cursorcolumn!<CR>
    map xy :s/x/y/g<CR>
    map yx :s/y/x/g<CR>

  " Copy paste to from clipboard <- ctrl+p
    if $os !=? 'termux'
      " Disabled in termux for wheel
      nnoremap <C-y> "+y
      vnoremap <C-y> "+y
    endif
    nnoremap <C-p> "+p
    vnoremap <C-p> "+p
    " Note: `] goto end of paste
    inoremap <C-p> <Esc>"+p`]a

  " Command : %% to expand path in command mode
    cnoremap %% <C-R>=expand('%:p:h').'/'<CR>|

  " Insert mode begin, end <- c-a c-e shotcuts from gnome
    inoremap <C-A> <C-O>^
    inoremap <C-E> <C-O>g_
    "inoremap <C-K> <C-O>D

  " Esc <- jk or kj
    imap jk <Esc>
    imap kj <Esc>

  " C-Arrow on Ubuntu
    "Get Ctrl + ARROW KEYS,because if you don't do that, the <C-Up>  (ie crtl + up ) key is notreckognise
    map  <Esc>[1;5A <C-Up>
    map  <Esc>[1;5B <C-Down>
    map  <Esc>[1;5D <C-Left>
    map  <Esc>[1;5C <C-Right>
    cmap <Esc>[1;5A <C-Up>
    cmap <Esc>[1;5B <C-Down>
    cmap <Esc>[1;5D <C-Left>
    cmap <Esc>[1;5C <C-Right>

    map  <Esc>[1;2D <S-Left>
    map  <Esc>[1;2C <S-Right>
    cmap <Esc>[1;2D <S-Left>
    cmap <Esc>[1;2C <S-Right>

  " Save with s
    noremap s      :update!<CR>
    vnoremap s    <C-C>:update!<CR>

  " Commenting blocks of code with ,cc ,cu
    " TODO better map
    " autocmd FileType c,cpp,java,scala let b:comment_leader = '// '
    " autocmd FileType sh,ruby,python   let b:comment_leader = '# '
    " autocmd FileType conf,fstab       let b:comment_leader = '# '
    " autocmd FileType tex              let b:comment_leader = '% '
    " autocmd FileType mail             let b:comment_leader = '> '
    " autocmd FileType vim              let b:comment_leader = '" '
    " noremap <silent> ,cc :<C-B>silent <C-E>s/^/<C-R>=escape(b:comment_leader,'\/')<CR>/<CR>:nohlsearch<CR>
    " noremap <silent> ,cu :<C-B>silent <C-E>s/^\V<C-R>=escape(b:comment_leader,'\/')<CR>//e<CR>:nohlsearch<CR>

  " Fold
    nnoremap <space> za
    vnoremap <space> zf
    map z1  :set foldlevel=0<CR><Esc>
    map z2  :set foldlevel=1<CR><Esc>
    map z3  :set foldlevel=2<CR><Esc>
    map z4  :set foldlevel=3<CR><Esc>
    map z5  :set foldlevel=4<CR><Esc>
    map z6  :set foldlevel=5<CR><Esc>
    map z7  :set foldlevel=6<CR><Esc>
    map z8  :set foldlevel=7<CR><Esc>
    map z9  :set foldlevel=8<CR><Esc>
    " And for azery
    map z& z1
    map zé z2
    map z" z3
    map z' z4
    map z( z5
    map z- z6
    map zè z7
    map z_ z8
    map zç z9

  " Tab
    noremap gn :tabnew<CR>
    noremap g1 :1tabnext<CR><Esc>
    noremap g2 :2tabnext<CR><Esc>
    noremap g3 :3tabnext<CR><Esc>
    noremap g4 :4tabnext<CR><Esc>
    noremap g5 :5tabnext<CR><Esc>
    noremap g6 :6tabnext<CR><Esc>
    noremap g7 :7tabnext<CR><Esc>
    noremap g8 :8tabnext<CR><Esc>
    noremap g9 :9tabnext<CR><Esc>
    " And for azery
    map g& g1
    map gé g2
    map g" g3
    map g' g4
    map g( g5
    map g- g6
    map gè g7
    map g_ g8
    map gç g9


" Command Man
  if exists(':Man') != 2
    com! -nargs=+ -complete=shellcmd M ru! ftplugin/man.vim | Man <args>
  else
    com! -nargs=+ -complete=shellcmd M Man <args>
  endif


" Folding
  highlight Folded ctermfg=DarkGreen ctermbg=Black
  set foldlevelstart=30 "the folding at opening
  set foldmethod=indent
  set foldcolumn=0  "the number of columns on the left to show the tree, default =0
  set foldlevelstart=30 "the folding at opening
  set shiftwidth=4  " the number of column taken into account for aa fold, IMPORTANT


" Filetype
  augroup FtDetect
    au BufNewFile,BufRead *.masm      setf masm
    au BufNewFile,BufRead *.asm       setf masm
    au BufNewFile,BufRead *.disarm    setf disarm
    au BufNewFile,BufRead *.kd        setf kd
  augroup END


" Plugin
  " YouCompleteMe
    let g:ycm_always_populate_location_list = 1 " use :lne and :lp to navigate
    let g:ycm_python_binary_path = 'python3'
    let g:ycm_autoclose_preview_window_after_completion = 1
    let g:ycm_min_num_of_chars_for_completion = 1

  " Pymode (package python-mode)
    let g:pymode_python = 'python3'
    " They `set nowrap` !!
    let g:pymode_options = 0
    let pymode_lint_checkers = ['pylint', 'pep8', 'pyflakes']
    " Use rope
    let g:pymode_rope = 1
    let g:pymode_rope_completion = 1
    let g:pymode_rope_complete_on_dot = 0
    let g:pymode_rope_completion_bind = '<C-Space>'
    let g:pymode_rope_autoimport = 0
    let g:pymode_rope_autoimport_modules = ['os', 'shutil', 'datetime', 'numpy']
    let g:pymode_rope_goto_definition_bind = '<C-]>'
    let g:pymode_rope_goto_definition_cmd = 'e'
    " Auto open cwindow (quickfix) if any errors have been found
    let g:pymode_lint_cwindow = 0
    " Pylint ignore
      let s = []
      " Important
      call add(s, 'E303')  " Too many blank lines
      call add(s, 'E501')  " Line too long > 80
      call add(s, 'E701')  " Multiple statement on one line
      call add(s, 'E702')  " Multiple statement on one line (colon)

      " For vimspector
      call add(s, 'E111')  " Indentation not a multiple of 4
      call add(s, 'E114')  " Indentation not a multiple of 4 (comment)
      call add(s, 'E201')  " Whitespace after '('
      call add(s, 'E202')  " Whitespace before ')'
      call add(s, 'E251')  " unespected space around keyword / operator =
      call add(s, 'E131')  " continuation line unaligned for hanging indent
      call add(s, 'E129')  " visually indented line with same indent as next logical line 
      " For dirty cats (jupyter-vim)
      " call add(s, 'E302')  " Expected 2 blank lines, found 1
      " call add(s, 'E265')  " Block comment should start with '# '
      " call add(s, 'E305')  " Expected 2 blank lines after class or function definition, found 1

      let pymode_lint_ignore = s
    " Do not perform mapping in ipython (it removes my previous <c-s>
    let g:ipy_perform_mappings = 0
    " Do not highlight spaces
    let g:pymode_syntax_space_errors = 0
    " Do not overwrite my ,b map
    let g:pymode_breakpoint = 0
    " Stop harassing me
    let g:pymode_options_max_line_length = 120
    " Fast fix
    sign define Pymode' text=1

  " ConqueDbg, a gdb plugging
    let g:ConqueGdb_Disable = 1
    let g:ConqueTerm_Color = 2         " 1: strip color after 200 lines, 2: always with color
    let g:ConqueTerm_CloseOnEnd = 1    " close conque when program ends running
    let g:ConqueTerm_StartMessages = 0 " display warning messages if conqueTerm is configured incorrectly
    let g:ConqueTerm_PyVersion = 3

  " Vdebug
    let g:vdebug_keymap = {
    \    'run' : '<F5>',
    \    'close' : '<F6>',
    \    'detach' : '<F7>',
    \    'run_to_cursor' : '<F8>',
    \    'set_breakpoint' : '<F9>',
    \    'step_over' : '<F10>',
    \    'step_into' : '<F11>',
    \    'step_out' : '<F12>',
    \    'get_context' : '<F2>',
    \    'eval_under_cursor' : '<F3>',
    \    'eval_visual' : '<Leader>e',
    \}

  " CtrlP
    " Open buffer here
    let g:ctrlp_switch_buffer = ''
    " Cache
    let g:ctrlp_cache_dir ='$h/.cache/ctrlp'
    " replace $home by ~ in cache
    let g:ctrlp_tilde_homedir = 1
    let g:ctrlp_mruf_max = 50000
    " Use ag <- grep
    " if executable('ag')
    "   let g:ctrl_user_command = 'ag %s -l --nocolor -g ""'
    " endif
    " Ignore
    let g:ctrlp_cutom_ignore = {
      \ 'dir': '\.git$,undo/',
      \ 'file': 'log'
    \ }
    if $os !=? 'termux'
      " E like edit and closer to ctrl + <c-p> used to paste
      let g:ctrlp_map = '<C-E>'
      vnoremap <C-E> :<C-u>CtrlPMixed<CR>
    else
      " Because move up gives c-e
      let g:ctrlp_map = ',e'
    endif
    " Keep cache
    let g:ctrlp_clear_cache_on_exit = 0
    " Mixed to search in MRU, FIles, Buffers
    let g:ctrlp_types = ['buf', 'mru', 'fil']
    let g:ctrlp_cmd = 'CtrlPMixed'
    " Faster listing <- vim.globpath
    if $os ==? 'windows'
      let g:ctrlp_user_command = 'dir %s /-n /b /s /a-d'
    else
      let g:ctrlp_user_command = 'find %s -type f'
    endif

  " Vim Translator
    ".vimrc
    " language code iso 639-1
    "? define key in visual-mode (optional)
    let g:goog_user_conf = { 'langpair': 'en|ru', 'cmd': 'node', 'v_key': 'T' }

  " AnsiEsc
    " au BufWinEnter *.a.txt AnsiEsc
    " au BufWinEnter *.a.txt set nowrap | echom "I saw an ansi file"
    " au ColorScheme * AnsiEsc!

  " Emacs Command line
    let g:EmacsCommandLineSearchCommandLineDisable = 1

  " Eclim
    let g:EclimCompletionMethod = 'omnifunc'

  " Vimtex
    " Disable overfull/underfull \hbox
    let g:vimtex_quickfix_latexlog = {
        \ 'overfull' : 0,
        \ 'underfull' : 0,
        \}

  " Ultisnip
    let g:UltiSnipsSnippetDirectories = [$v . '/template/my_snippets', $v . '/pack/bundle/opt/snippets/UltiSnips']
    " Disable search in rtp because I already gave you the path
    let g:UltiSnipsEnableSnipMate = 0

    let g:UltiSnipsExpandTrigger='<c-j>'
    let g:UltiSnipsUsePythonVersion = 3

  " Fugitive
    map <leader>gd :Gdiff<CR>
    map <leader>gb :Gblame<CR>
    map <leader>gs :Gstatus<CR>
    map <leader>gl :Glog<CR>
    map <leader>gc :Gcommit -m ""<C-b>
    map <leader>ga :Git add

  " Viewdoc
    let g:no_viewdoc_abbrev = 1
    let g:viewdoc_open = 'e'

  " Table mode
    let g:table_mode_tableize_map = ',i'

  " Vimwiki
    " Wiki
    let g:vimwiki_list = [{
      \ 'path': '$h/wiki/wiki',
      \ 'path_html': '$h/wiki/wiki_html'
      \ }]
    " Todo
    let g:vimwiki_list += [{
      \ 'path': '$h/wiki/todo',
      \ 'path_html': '$h/wiki/todo_html'
      \ }]
    " Test
    let g:vimwiki_list += [{
      \ 'path': '$h/Test/Wiki',
      \ 'path_html': '$h/Tast/Wiki_html'
      \ }]
    augroup Wiki
      au BufNewFile,BufRead */todo      setf vimwiki
    augroup END
    " Map
    noremap <leader>ww :VimwikiIndex 1<CR>
    map <leader>tt :VimwikiIndex 2<CR>
    map <leader>t<leader>t :VimwikiDiaryIndex 2<CR>
    function! Windex(num)
      let l:nr = 1 + vimwiki#vars#get_bufferlocal('wiki_nr')
      if &filetype !=# 'vimwiki' || l:nr != a:num
        execute 'VimwikiIndex ' . a:num
      endif
    endfunction
    noremap <leader>wg :call Windex(1)<CR>:VimwikiGoto 
    noremap <leader>tg :call Windex(2)<CR>:VimwikiGoto 
    map <leader>k :packadd calendar <bar> Calendar<CR>
    " Option
    let g:vimwiki_table_reduce_last_col = 1
    let g:vimwiki_table_mappings = 0
    let g:vimwiki_table_auto_fmt = 1
    let g:vimwiki_automatic_nested_syntaxes = 1
    let g:vimwiki_syntax = 'markdown'
    let g:vimwiki_ext = '.md'
    let g:vimwiki_custom_wiki2html = '$h/wiki/wiki/wiki2html.sh'
    let g:vimwiki_css_name = '/Css/include.css'

    " augroup VimwikInit
    "     autocmd FileType vimwiki set nomodeline
    " augroup END

    packadd wiki " TODO remove and add autoload
    " Calendar
    let g:calendar_monday = 1

  " Ack to use ag
    let g:ack_qhandler='rightbelow vert copen 80'
    " a -> Ag the silver searcher <- ack
    noremap <leader>a :silent packadd ack<CR>:Ack! ''<LEFT>
    let g:ackprg = 'ag --vimgrep --smart-case'
    cnoreabbrev ag Ack
    cnoreabbrev aG Ack
    cnoreabbrev Ag Ack
    cnoreabbrev AG Ack

  " Vimspector
    let g:vimspector_enable_mappings = 'HUMAN'


" PackAdd
  set packpath+=$v
  " Interface
  packadd fugitive
  packadd ctrlp " 3ms
  " Map
  packadd surround  " ySS<div>
  packadd repeat  " for surround
  packadd textobj-user  " for function
  packadd textobj-arg  " daa
  packadd textobj-indent  " dai
  packadd textobj-function  " daf
  " Snip
  packadd ultisnips " 3ms
  packadd snippets " for some ultisnips macro
  " Slow : reload on demand
  packadd emacscommandline
  " packadd unimpaired  " ]b (:bn) , ]<space> (add empty lines)



" Fastly (added)
  command! -nargs=0 -bar Helptags for p in glob('~/.vim/pack/bundle/opt/*', 1, 1) | exe 'packadd '.fnamemodify(p, ':t') | endfor | helptags ALL

  " packadd perlomni
  "packadd lexima " autoclose brackets
  "packadd xmledit
  "let xml_use_html = 1

  imap   <C-k>   <plug>(emmet-expand-abbr)
  " packadd emmet
  "imap   <C-k>   <plug>(emmet-expand-abbr)
  "let g:jupyter_monitor_console = 1
  "let g:jupyter_verbose = 1
  "let g:jupyter_auto_connect = 1
  "packadd jupyter
  "packadd python-mode
  packadd spector
  " packadd youcompleteme
  " if $os == 'unix' packadd youcompleteme endif
  packadd ale
  packadd raku
  " packadd sleuth  " Auto indent
  let g:ycm_confirm_extra_conf = 0

  map K :echo "hi<" . synIDattr(synID(line("."),col("."),1),"name") . '> trans<' . synIDattr(synID(line("."),col("."),0),"name") . "> lo<" . synIDattr(synIDtrans(synID(line("."),col("."),1)),"name") . ">"<CR>

" vim:sw=2:ts=2
